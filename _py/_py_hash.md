# 原理
[代码随想录](https://programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0)
主要用于判断一个元素是否在集合里 
![[IMG/Pasted image 20250215174458.png]]
## 哈希碰撞的解决方案
哈希碰撞：不同的元素被hash function映射到了hash table的相同位置。

| Solution | 原理                           | Comments                                             |
| -------- | ---------------------------- | ---------------------------------------------------- |
| 拉链法      | 发生冲突的元素被存储在列表中，可以通过索引找到效力和小王 | 选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。 |
| 线性探测法    | 向下找一个空位放置冲突的信息               | 一定要保证tableSize大于dataSize                             |

## 2种常见的哈希结构

|        | Dictionary                  | Set                                                        |
| ------ | --------------------------- | ---------------------------------------------------------- |
| Basics | 无序，但 `3.7+` 遍历时保持顺序。不能重复。   | 同左                                                         |
| 可修改？   | key 不可变，value 可变            | 1. `set` 可修改，可以添加或删除元素<br>2. `frozenset` **不可变**，一旦创建，不能修改 |
| Basics | [_py_dict](_py/_py_dict.md)          | [_py_set](_py_set.md)                                        |
| 添加     | `d[key] = value` → **O(1)** | `add()` → **O(1)**                                         |
| 删除     | `del d[key]`） → **O(1)**    | `remove()`  → **O(1)**                                     |
| 查找     | `d[key]` → **O(1)**         | `in` → **O(1)**                                            |
| 遍历     | `for key in d` → **O(n)**   | `for x in set`  → **O(n)**                                 |
