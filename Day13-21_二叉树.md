---
title: Day13-21_äºŒå‰æ ‘
tags: [LeetCode, äºŒå‰æ ‘]
categories: [Notes]
slug: äºŒå‰æ ‘
publish: true
---

# ç†è®º
[py_tree](_py/_py_tree.md)
# é¢˜ç›®
æˆ‘æŒ‰ç…§[éšæƒ³å½•](https://programmercarl.com/)çš„é¡ºåºåˆ·é¢˜ã€‚éšæœ‰å€Ÿé‰´æ€ç»´ï¼Œä½†ä»¥ä¸‹ä»£ç éƒ½æ˜¯è‡ªå·±å†™çš„
## DSPéå†
ã€æ³•ä¸€ Â· é€’å½’ã€‘
key: ç¡®å®šé€’å½’å‡½æ•°çš„å‚æ•°/è¿”å›å€¼ï¼›ç¡®å®šç»ˆæ­¢æ¡ä»¶ï¼›ç¡®å®šå•å±‚é€’å½’çš„é€»è¾‘
```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def preorderTraversal(self, root):
        """
        :type root: Optional[TreeNode]
        :rtype: List[int]
        """
        result = []
        def tvs(node):
            if node == None: return
            result.append(node.val) # ä¸­åºéå†åˆ™æŠŠè¿™å¥æ”¾åœ¨leftåï¼Œååˆ™æ”¾rightå
            tvs(node.left)
            tvs(node.right)
            return
        tvs(root)
        return result

```
æœ‰ä¸€ä¸ªå¾ˆç®€ç»ƒçš„å†™æ³•ï¼š

```python
class Solution(object):
    def preorderTraversal(self, root):
        if not root: return []
        return [root.val] + self.preorderTraversal(root.left) + self.preorderTraversal(root.right)
```

ã€æ³•äºŒï¼šè¿­ä»£ã€‘
å’Œé€’å½’æœ¬è´¨æ˜¯ä¸€æ ·çš„ï¼Œä½†æ˜¯éœ€è¦è‡ªå·±å‡†å¤‡ä¸€ä¸ªæ˜¾å¼çš„stack
- æ³¨æ„é¡ºåºå…¥æ ˆå‡ºæ ˆé¡ºåº
```python
# å‰åºéå†
class Solution(object):
    def preorderTraversal(self, root):
        if not root: return []
        stack = [root]
        result = []
        while stack:
            cur = stack.pop()
            result.append(cur.val)
            if cur.right: stack.append(cur.right)
            if cur.left: stack.append(cur.left)
        return result

# ååºéå†
# åªéœ€è¦åœ¨å‰åºéå†çš„åŸºç¡€ä¸Šè°ƒæ¢right/leftä¸¤è¡Œé¡ºåºï¼Œæœ€åæŠŠresultåè½¬ï¼Œå³result[::-1]å°±å¥½äº†

# ä¸­åºéå†
# æœ‰ç‚¹éš¾ï¼Œæš‚æ—¶è·³è¿‡
```

## BSPéå†
[102_md](https://leetcode.cn/problems/binary-tree-level-order-traversal/)
```python
class Solution:
    def levelOrder(self, root):
        if not root: return []
        queue = collections.deque([root])
        result = []
        while queue:
            level = []
            for _ in range(len(queue)):
                cur = queue.popleft()
                level.append(cur.val)
                if cur.left: queue.append(cur.left)
                if cur.right:queue.append(cur.right)
            result.append(level)
        return result
```
å±‚åºéå†å¯ä»¥ç”¨æ¥å¾ˆå¤šé¢˜ï¼Œå¦‚äºŒå‰æ ‘çš„å³è¯•å›¾ã€å±‚å¹³å‡å€¼/æœ€å¤§å€¼ã€æœ€å¤§/å°æ·±åº¦ã€äºŒå‰æ ‘çš„èŠ‚ç‚¹ä¸ªæ•°
ã€å˜å¼1ã€‘å¡«å……æ¯ä¸ªèŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹æŒ‡é’ˆ [17_md](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/)
```python
class Solution(object):
    def connect(self, root):
        """
        :type root: Node
        :rtype: Node
        """
        from collections import deque
        if not root: 
            return None
        queue = deque([root])
        while queue:
            length = len(queue) # lengthæå‰ç®—å¯ä»¥èŠ‚çœæ—¶é—´
            prev = None
            # iterate every level
            for i in range(length):
                cur = queue.popleft()
                if prev: prev.next = cur
                prev = cur
                if cur.left: queue.append(cur.left)
                if cur.right: queue.append(cur.right)
        return root
```
- æ³¨æ„ï¼Œè¿”å›çš„æ˜¯root
ã€å˜å¼2ã€‘æ‰¾æ ‘å·¦ä¸‹è§’çš„å€¼ [513é¢˜_md](https://leetcode.cn/problems/find-bottom-left-tree-value/description/)
ã€æˆ‘çš„æ€è·¯1ï¼šå±‚åºéå†ã€‘
- æ€è€ƒï¼šreturn result\[-1]\[0] (if not root: return None)
- æ­£ç¡®ï¼
ã€å˜å¼3ã€‘äºŒå‰æœç´¢æ ‘ä¸­çš„æœç´¢[700_ez](https://leetcode.cn/problems/search-in-a-binary-search-tree/)
 
 åè½¬åˆ—è¡¨ã€‚ä½†è¿™ä¸ªå°±ä¸å¤ªéœ€è¦ä¸€å±‚ä¸€å±‚çš„ã€‚åªéœ€è¦å€ŸåŠ©queueçš„æ€æƒ³éå†å°±å¥½äº†ã€‚
```python
class Solution(object):
    def invertTree(self, root):
        if not root: return root
        from collections import deque
        queue = deque([root])
        while queue:
            cur = queue.popleft()
            cur.left, cur.right = cur.right, cur.left
            if cur.left: queue.append(cur.left)
            if cur.right: queue.append(cur.right)
        return root
```

## å¯¹ç§°åˆ—è¡¨ï¼š
- æ³¨æ„ï¼šéœ€è¦å¯¹æ¯”çš„æ˜¯nodeçš„valè€Œä¸æ˜¯nodeï¼Œå› ä¸ºä¸¤ä¸ªnodeçš„å€¼ç›¸ç­‰ä½†åœ°å€ä¸åŒçš„è¯ï¼Œä¹Ÿæ˜¯ä¸ç›¸ç­‰çš„ã€‚
- ç‰¹æ®Šç‚¹ï¼šè¦å­˜`None`, ä¸”æœ‰`None` = `None`, `None`ä¹Ÿå¯ä»¥è¢«`pop`å‡ºæ¥ã€‚
ã€æˆ‘çš„å†™æ³•ï¼šå±‚åºéå†ï¼Œä½†è¾ƒä¸ºéº»çƒ¦ã€‘
```python
class Solution(object):
    def isSymmetric(self, root):
        """
        :type root: Optional[TreeNode]
        :rtype: bool
        """
        if not root: return True
        from collections import deque
        queue = deque([root])
        while queue:
            length = len(queue)
            level = []
            for i in range(length):
                cur = queue.popleft()
                if cur.left: 
                    queue.append(cur.left)
                    level.append(cur.left.val)
                elif not cur.left:
                    level.append(None)
                if cur.right: 
                    queue.append(cur.right)
                    level.append(cur.right.val)
                elif not cur.right:
                    level.append(None)
            if level != level[::-1]: return False
        return True
```
ã€ä¼˜åŒ–ã€‘
```python
class Solution(object):
    def isSymmetric(self, root):
        if not root: return True
        from collections import deque
        queue = deque([root])
        while queue:
            length = len(queue)
            level = []
            for i in range(length):
                cur = queue.popleft()
                if cur: 
                    queue.append(cur.left)
                    queue.append(cur.right)
                    level.append(cur.val)
                else:
                    level.append(None)
            if level != level[::-1]: return False
        return True
```

## æœ€å¤§æ·±åº¦
ã€æ³•ä¸€ï¼šå±‚åºéå†ã€‘
ã€æ³•äºŒï¼šé€’å½’ã€‘
```python
class Solution(object):
    def maxDepth(self, root):
        if not root: return 0
        left_depth = self.maxDepth(root.left)
        right_depth = self.maxDepth(root.right)
        return max(left_depth, right_depth) + 1
```

## å¹³è¡¡äºŒå‰æ ‘
- å’Œä¸Šä¸€é¢˜æœ€å¤§æ·±åº¦ç±»ä¼¼
- ç±»ä¼¼å»çœ‹æœ€å¤§æ·±åº¦ï¼Œä½†æ˜¯æ¯ä¸€æ¬¡ä¸ä»…è¦ç®—è¯¥å±‚çš„é«˜åº¦ï¼Œä¹Ÿè¦è®¡ç®—å·¦å­æ ‘ã€å³å­æ ‘æ˜¯å¦ç¬¦åˆAVLçš„æ¡ä»¶
- æ³¨æ„ï¼Œä¸èƒ½ç›´æ¥è¿”å›Falseï¼Œå› ä¸ºé€’å½’ä¸èƒ½ç«‹åˆ»åœæ­¢ã€‚
```python
class Solution(object):
    def isBalanced(self, root):
        def get_height(root):
            if not root:
                return 0
            left_height = get_height(root.left)
            right_height = get_height(root.right)
            if left_height == -1 or right_height == -1 or abs(left_height - right_height) > 1:
                return -1
            return max(left_height, right_height) + 1

        return get_height(root) != -1
```

## äºŒå‰æ ‘çš„æ‰€æœ‰è·¯å¾„
- è¦æƒ³å¥½è¾¹ç•Œæ¡ä»¶ã€‚
```python
class Solution(object):
    def binaryTreePaths(self, root):
        result = []
        def dfs(root, path):
            if not root.left and not root.right:
                result.append(path)
                return 
            if root.left:
                dfs(root.left, path + "->" + str(root.left.val))
            if root.right:
                dfs(root.right, path + "->" + str(root.right.val))
            return 
        if not root: return []
        dfs(root, str(root.val))
        return result
```
ã€å˜ä½“ï¼šè·¯å¾„æ€»å’Œã€‘[112_ez](https://leetcode.cn/problems/path-sum/)
- åªéœ€æ¯æ¬¡ä¼ çš„å‚æ•°å˜ä¸º `num`, pathå˜æˆå’Œï¼Œæœ€å`return targetSum in result`
## å·¦å¶å­ä¹‹å’Œ
[404é¢˜_ez](https://leetcode.cn/problems/sum-of-left-leaves/description/)
ã€æˆ‘çš„æ€è·¯1ï¼šé€’å½’ã€‘
- æ€è€ƒï¼šå…³é”®ç‚¹åœ¨äºè¦ç¡®å®šä»€ä¹ˆæ˜¯â€œå·¦å¶å­â€ï¼šâ€œå·¦â€ï¼ˆé€šè¿‡æ ‡è®°å®ç°ï¼‰ï¼Œâ€œå¶å­â€ï¼šå®ƒæ²¡æœ‰å·¦å’Œå³å­©å­ã€‚
- æ³¨æ„ï¼špythonä¸­å‡½æ•°çš„ä½œç”¨åŸŸé—®é¢˜ã€‚
	- æˆ‘åˆšå¼€å§‹æ²¡æœ‰å†™`nonlocal result` è¿™ä¸€å¥ï¼Œå¯¼è‡´â€œlocal variableåœ¨asignä¹‹å‰æœªå£°æ˜â€œçš„æŠ¥é”™ã€‚

| æƒ…å†µ              | æ˜¯å¦å¯ä»¥è®¿é—® |
| --------------- | ------ |
| å‡½æ•°å†…è¯»å–å¤–éƒ¨å˜é‡       | å¯ä»¥     |
| å‡½æ•°å†…â€œèµ‹å€¼â€å¤–éƒ¨å˜é‡     | ä¸å¯ä»¥    |
| å‡½æ•°å†…â€œappendâ€å¤–éƒ¨å˜é‡ | å¯ä»¥     |
```python
class Solution(object):
    def sumOfLeftLeaves(self, root):
        result = 0
        def dfs(root, left_leaf = False):
	        nonlocal result # æŒ‡æ˜è¿™ä¸ªresultæ˜¯å¤–éƒ¨çš„ï¼Œåœ¨å¤–é¢å»æ‰¾ã€‚ä½†python3æ‰å¯ä»¥ç”¨
            if not root.left and not root.right and left_leaf:
                result += root.val
                return
            if root.left: dfs(root.left, True)
            if root.right: dfs(root.right, False)
            return
        if not root: return 0
        dfs(root)
        return result
        # comment: å¦ä¸€ä¸ªä¸å¤ªä¼˜é›…çš„solutionæ˜¯result = []ï¼Œæ¯æ¬¡æœ‰resultäº†ä»¥åå°±append, æœ€åreturn sum(result)
```

ã€æˆ‘çš„æ€è·¯2ï¼šå¥—å±‚åºéå†æ¨¡æ¿ã€‘
- æ€è€ƒï¼šå¯¹äºæ¯ä¸€ä¸ªnodeï¼Œcheckå…¶å·¦å­©å­æ»¡è¶³æ¡ä»¶ï¼š`node.left and not node.left.left and not node.left.right`
- ç”±äºpythonæ˜¯ç¬¬ä¸€ä¸ªæ¡ä»¶ä¸æ»¡è¶³å°±ç›´æ¥è·³è¿‡ï¼Œä¸éœ€è¦æ‹…å¿ƒNone.leftè¿™ä¸€ç±»æŠ¥é”™ã€‚
```python
class Solution:
    def sumOfLeftLeaves(self, root):
        if root is None:
            return 0
        st = [root]
        result = 0
        while st:
            node = st.pop()
            if node.left and not node.left.left and not node.left.right:
                result += node.left.val
            if node.right:
                st.append(node.right)
            if node.left:
                st.append(node.left)
        return result
```


##  ä»ä¸­åºä¸ååºéå†åºåˆ—æ„é€ äºŒå‰æ ‘
[106_md](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)
ã€æˆ‘çš„æ€è·¯1ï¼šé€’å½’ã€‘
- é¦–å…ˆï¼Œæ˜¯å…³äºå¦‚ä½•ä»ä¸­åº + ååºå¾—åˆ°äºŒå‰æ ‘ï¼špostorder\[-1]å³ä¸ºroot, inorderä»rootåˆ†å¼€å³ä¸ºå·¦å­æ ‘å’Œå³å­æ ‘çš„ä¿¡æ¯ï¼Œpostorderä¹Ÿä»¥åŒæ ·çš„é•¿åº¦åˆ†å¼€ã€‚ç„¶åè¿›è¡ŒåŒæ ·çš„æ“ä½œã€‚å¾ˆå®¹æ˜“æƒ³åˆ°éœ€è¦é€’å½’ã€‚
- é€’å½’åˆ™éœ€è¦ç¡®å®šå‡ ä¸ªå†…å®¹ï¼š
	- è¿”å›å€¼ï¼šæœ€ç»ˆåº”è¯¥æ˜¯root
	- è¾¹ç•Œæ¡ä»¶ï¼šå¦‚æœsträ¸ºç©ºï¼Œåˆ™`return None`
- æ³¨æ„ï¼šå¦‚æœé€’å½’è‡ªå·±éœ€è¦åŠ `self.`ã€‚å¦‚æœè¦å•ç‹¬å†å†™ä¸€ä¸ªé€’å½’å‡½æ•°ï¼Œè¦åšå¥½ç©ºæ ¼ï¼Œç„¶åä¸éœ€è¦selfï¼Œè¦æ”¾åœ¨å‰é¢ï¼ˆæ³¨æ„å‡½æ•°çš„ä½œç”¨åŸŸé—®é¢˜ï¼‰ã€‚
```python
 class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:
        if not len(inorder): return None
        if len(inorder) == 1:
            return TreeNode(inorder[0])

        # slice the str
        node = TreeNode(postorder[-1])
        idx = inorder.index(postorder[-1])
        left_in = inorder[0:idx]
        left_pos = postorder[0:idx]
        right_in = inorder[idx+1:]
        right_pos = postorder[idx:-1]

        if left_in: 
            node.left = self.buildTree(left_in, left_pos)
        if right_in:
            node.right = self.buildTree(right_in, right_pos)
        return node
```
ã€éšæƒ³å½•ï¼šä¼˜åŒ– Â· ç»ˆæ­¢æ¡ä»¶æ›´åŠ æ™®é€‚ã€‘ä½†æœ¬è´¨æ˜¯ä¸€æ ·çš„ã€‚ï¼ˆæ„Ÿè§‰è‡ªå·±çš„æ›´å¥½ç†è§£ï¼‰

```python
class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode:
        if not postorder:
            return None

        root_val = postorder[-1]
        root = TreeNode(root_val)

        separator_idx = inorder.index(root_val)
        inorder_left = inorder[:separator_idx]
        inorder_right = inorder[separator_idx + 1:]
        postorder_left = postorder[:len(inorder_left)]
        postorder_right = postorder[len(inorder_left): len(postorder) - 1]


        root.left = self.buildTree(inorder_left, postorder_left)
        root.right = self.buildTree(inorder_right, postorder_right)

        return root
```

ã€å˜å¼ã€‘æœ€å¤§äºŒå‰æ ‘ [654_md](https://leetcode.cn/problems/maximum-binary-tree/description/)
```python
class Solution:
    def constructMaximumBinaryTree(self, nums: List[int]) -> Optional[TreeNode]:
        if not nums:
            return None
        max_val = max(nums)
        idx = nums.index(max_val)
        node = TreeNode(max_val)
        node.left = self.constructMaximumBinaryTree(nums[:idx])
        node.right = self.constructMaximumBinaryTree(nums[idx+1:])
        return node
```

## åˆå¹¶äºŒå‰æ ‘
[617_ez](https://leetcode.cn/problems/merge-two-binary-trees/description/)
ã€æˆ‘çš„æ€è·¯1ï¼šè¿­ä»£ã€‘
- æ€è·¯ï¼šæƒ³ä½¿ç”¨å‰åºéå†ï¼Œåªæ˜¯æ˜¯åŒæ—¶ä¼ å…¥ä¸¤ä¸ªå‚æ•°ã€‚
- æˆ‘è¿™é‡Œæ˜¯æ‰€æœ‰èŠ‚ç‚¹éƒ½æ–°å»ºäº†ã€‚
```python
class Solution:
    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root1 and not root2:
            return None
        if root1 and not root2: node = TreeNode(root1.val)
        elif not root1 and root2: node = TreeNode(root2.val)
        else: node = TreeNode(root2.val+root1.val)

        node.left = self.mergeTrees(root1.left if root1 else None, root2.left if root2 else None)
        node.right = self.mergeTrees(root1.right if root1 else None, root2.right if root2 else None)
        return node
```
ã€éšæƒ³å½• Â· ä¼˜åŒ–ä¹‹ä¸æ–°å»ºNodeã€‘
- è¿™æ ·å¯ä»¥åˆ©ç”¨ä¸¤æ£µæ ‘åŸæœ¬çš„ç»“æ„
```python
class Solution:
    def mergeTrees(self, root1: TreeNode, root2: TreeNode) -> TreeNode:
        if not root1: 
            return root2
        if not root2: 
            return root1
        # ä¸Šé¢çš„é€’å½’ç»ˆæ­¢æ¡ä»¶ä¿è¯äº†ä»£ç æ‰§è¡Œåˆ°è¿™é‡Œroot1, root2éƒ½éç©º. 
        root = TreeNode(root1.val + root2.val)
        root.left = self.mergeTrees(root1.left, root2.left)
        root.right = self.mergeTrees(root1.right, root2.right)
        return root
```
## äºŒå‰æœç´¢æ ‘ä¸­çš„æœç´¢
[700_ez](https://leetcode.cn/problems/search-in-a-binary-search-tree/)
ã€æˆ‘çš„æ€è·¯1ï¼šå±‚åºéå†ã€‘
ã€éšæƒ³å½•ä¼˜åŒ– Â· ä½¿ç”¨äºŒå‰æ ‘æ€§è´¨ã€‘
- åˆ©ç”¨å¤§å°å…³ç³»ï¼Œå¯ä»¥ä¸ç”¨éå†ã€‚
- é€’å½’å’Œè¿­ä»£éƒ½å¯ä»¥
```python
class Solution:
    def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
        if not root: return None

        if root.val == val: return root
        elif root.val > val:
            return self.searchBST(root.left,val)
        else:
            return self.searchBST(root.right,val)
```
```python
class Solution:
    def searchBST(self, root: TreeNode, val: int) -> TreeNode:
        while root:
            if val < root.val: root = root.left
            elif val > root.val: root = root.right
            else: return root
        return None
```
[py_copy](_py/_py_copy.md)

## éªŒè¯äºŒå‰æœç´¢æ ‘
[98_md](https://leetcode.cn/problems/validate-binary-search-tree/) 
ã€æˆ‘çš„æ€è·¯1ã€‘
æ€è·¯ï¼šä¸­åºéå†å±•å¼€ï¼Œç”¨æ•°ç»„å‚¨å­˜ã€‚Checkæ˜¯å¦ 1. sorted 2. æœ‰é‡å¤å…ƒç´ 
```python

class Solution:
    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        result= []
        def inorder(root):
            if not root: return None
            inorder(root.left)
            result.append(root.val)
            inorder(root.right)
            return
        inorder(root)
        sorted_result = sorted(result)
        for i in range(len(sorted_result) - 1):
            if sorted_result[i] == sorted_result[i+1]:
                return False
        return sorted_result == result
```
ã€éšæƒ³å½• Â· é€’å½’ & è¿­ä»£ã€‘è®¾ä¸€ä¸ªpreçš„å˜é‡ï¼Œä¸‹ä¸€é¢˜ä¹Ÿæ˜¯ã€‚è¿™æ¬¡å°±å…ˆä¸æŒæ¡äº†ï¼Œæ ‡è®°ä¸€ä¸‹ã€‚
## äºŒå‰æœç´¢æ ‘çš„æœ€å°ç»å¯¹å·®
[530_ez](https://leetcode.cn/problems/minimum-absolute-difference-in-bst/)
ã€æˆ‘çš„æ€è·¯1ï¼šä¸­åºéå†ã€‘
æ€è·¯ï¼šå±•å¼€ï¼Œç„¶åä¸€ä¸ªå¾ªç¯ç®—ç›¸é‚»ä¹‹é—´çš„å·®å€¼ã€‚ä¼˜åŒ–çš„è¯å¯ä»¥æœ‰ä¸€äº›pruningçš„æ“ä½œï¼Œæ¯”å¦‚ï¼Œå¦‚æœæœ‰ç›¸åŒçš„å°±`return 0`ï¼ˆä¸ç¡®å®šæ˜¯å¦æœ‰ç”¨ï¼‰ã€‚
æ³¨ï¼šè¦å¥½å¥½åˆ©ç”¨äºŒå‰æ ‘çš„æ€§è´¨ï¼è€Œä¸­æ—¬éå†å°±å¯ä»¥å¾ˆå¥½åœ°ä¿ç•™å…¶æœ‰åºæ€§ã€‚
```python
class Solution:
    def getMinimumDifference(self, root: Optional[TreeNode]) -> int:
        if not root: return root
        result = []
        min_diff = float("inf")
        def tvs(node):
            if node == None: return
            tvs(node.left)
            result.append(node.val)
            tvs(node.right)
            return
        tvs(root)
        for i in range(len(result)-1):
            diff = abs(result[i]-result[i+1])
            if diff == 0: return 0
            min_diff = min(min_diff, diff)
        return min_diff
```

ã€éšæƒ³å½•ä¼˜åŒ– Â· éå†è¿‡ç¨‹ä¸­å°±è¿›è¡Œæ¯”è¾ƒã€‘
- è¿™æ ·å¯ä»¥ä¸å»ºæ•°ç»„ã€‚éœ€è¦ç”³æ˜ä¸€ä¸ªå˜é‡`pre_val`æ¥è®°å½•éå†åˆ°çš„ä¸Šä¸€ä¸ªèŠ‚ç‚¹çš„å€¼
```python
class Solution:
    def getMinimumDifference(self, root: Optional[TreeNode]) -> int:
        if not root: return root
        min_diff = float("inf")
        pre_val = float("inf")
        def tvs(node):
            nonlocal min_diff, pre_val
            if node == None: return
            tvs(node.left)
            min_diff = min(min_diff, abs(pre_val - node.val))
            pre_val = node.val
            tvs(node.right)
            return
        tvs(root)
        return min_diff
```

- æ³¨æ„ï¼Œå‡½æ•°å†…éƒ¨ä½¿ç”¨nonlocalçš„æ›¿ä»£æ–¹æ³•ï¼šåœ¨åˆ›å»ºä¸€ä¸ªç±»çš„å¯¹è±¡æ—¶ï¼Œ`__init__` æ–¹æ³•ä¼šè‡ªåŠ¨è¿è¡Œï¼Œç”¨æ¥åˆå§‹åŒ–ç±»å¯¹è±¡çš„å±æ€§ï¼ˆæˆå‘˜å˜é‡ï¼‰ã€‚éœ€è¦é€šè¿‡ `self.member` è®¿é—®ã€‚
```python
class Solution:
    def __init__(self):
        self.result = float('inf')
        self.pre = None

    def traversal(self, cur):
        if cur is None:
            return
        self.traversal(cur.left)  # å·¦
        if self.pre is not None:  # ä¸­
            self.result = min(self.result, cur.val - self.pre.val)
        self.pre = cur  # è®°å½•å‰ä¸€ä¸ª
        self.traversal(cur.right)  # å³

    def getMinimumDifference(self, root):
        self.traversal(root)
        return self.result
```

## äºŒå‰æœç´¢æ ‘ä¸­çš„ä¼—æ•°
[501_ez](https://leetcode.cn/problems/find-mode-in-binary-search-tree/)
ã€æˆ‘çš„æ€è·¯1ï¼šæš´åŠ›å±•å¼€ï¼Œç„¶åä½¿ç”¨Countã€‘
- åŸºç¡€çŸ¥è¯†ï¼š[_py_dict](_py/_py_dict.md) é‡Œé¢æ€»ç»“äº†ç›¸å…³åº“å¦‚ `defaultdict` å’Œ `Counter`çš„ç”¨æ³•
- ç¼ºç‚¹æ˜¯æ²¡æœ‰ç”¨åˆ°äºŒå‰æ ‘çš„æ€§è´¨
```python
from collections import Counter
class Solution:
    def __init__(self):
        self.result = []
        self.most_frec_element = []
    def inorder_dfs(self, root):
        if not root: return
        self.inorder_dfs(root.left)
        self.result.append(root.val)
        self.inorder_dfs(root.right)
        return self.result

    def findMode(self, root: Optional[TreeNode]) -> List[int]:
        count = Counter(self.inorder_dfs(root))
        max_freq = max(count.values())
        return [val for val, freq in count.items() if freq == max_freq]
```

ã€ä¼˜åŒ–by gptï¼šä¸ä½¿ç”¨å±€éƒ¨å˜é‡ã€‘
- è¿™ç›¸å½“äºæˆ‘`def __init__(self)`ä»¥åŠ`def inorder_dfs(self, root):` è¿™ä¸¤ä¸ªå‡½æ•°çš„ä½œç”¨ã€‚
```python
class Solution:
    def inorder_dfs(self, root):
        if not root:
            return []
        return self.inorder_dfs(root.left) + [root.val] + self.inorder_dfs(root.right)
```

ã€éšæƒ³å½• Â· ä¼˜åŒ–ï¼šåˆ©ç”¨äºŒå‰æ ‘æ€§è´¨ã€‘
- åˆ©ç”¨ä¸­åºéå†æ—¶æ˜¯é¡ºåºã€‚ç„¶åæˆ‘ä»¬ç”¨ä¸€ä¸ªå˜é‡`pre`ä¿ç•™å‰ä¸€ä¸ªèŠ‚ç‚¹çš„ä¿¡æ¯ã€‚
```python
from collections import Counter
class Solution:
    def __init__(self):
        self.pre = None
        self.count = 0
        self.max_count = -1
        self.result = []

    def findMode(self, root: Optional[TreeNode]) -> List[int]:
        def dfs(node):
            if not node:
                return
            
            dfs(node.left)

            if not self.pre or self.pre.val != node.val:
                self.count = 1
            else:
                self.count += 1

            if self.count > self.max_count:
                self.max_count = self.count
                self.result = [node.val]
            elif self.count == self.max_count:
                self.result.append(node.val)
                
            self.pre = node

            dfs(node.right)

        dfs(root)

        return self.result
```

## äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ
[236_md](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/)
ã€æˆ‘çš„æ€è·¯1:ä¸­åºéå† + é€’å½’ã€‘
- é€’å½’çš„é€»è¾‘æ˜¯ï¼Œå¦‚æœä»rootæŠŠä¸­åºéå†çš„ç»“æœåˆ†æˆå·¦å­æ ‘ã€å³å­æ ‘ä¸¤ä¸ªstringï¼Œå¦‚æœroot.valåœ¨åŒä¸€è¾¹ï¼Œåˆ™ç»§ç»­è¿­ä»£ï¼Œå¦åˆ™rootä¸ºæœ€å¤§å…¬å…±ç¥–å…ˆï¼ˆåŒ…å«rootå°±æ˜¯q/pçš„æƒ…å†µï¼‰ã€‚ä¼ å…¥çš„å‚æ•°æœ‰ä¸€ä¸ªlistã€‚
- è™½ç„¶è¿‡äº†ï¼Œä½†æ¶ˆè€—çš„å†…å­˜å’Œæ—¶é—´éƒ½ç‰¹åˆ«å¤š
- æ³¨æ„è§‚å¯Ÿä¼ å…¥ã€ä¼ å‡ºå€¼çš„æ•°æ®ç±»å‹ï¼debugäº†å¥½ä¹…ğŸ˜­
```python
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        result = self.in_tvs(root)
        return self.helper(root, p, q, result)

    def helper(self, root, p, q, _list):
        if root == None:
            return None
        if root.val == q.val or root.val == p.val:
            return root
        idx = _list.index(root.val)
        left_list = _list[:idx]
        right_list = _list[idx+1:]
        if q.val in left_list and p.val in left_list:
            return self.helper(root.left, p, q, left_list)
        elif q.val in right_list and p.val in right_list:
            return self.helper(root.right, p, q, right_list)
        else:
            return root

    def in_tvs(self, node):
        if node == None: return []
        return self.in_tvs(node.left) + [node.val] + self.in_tvs(node.right)
```

ã€éšæƒ³å½• Â· ä¼˜åŒ– Â· ååºéå†ä¹‹é€’å½’ã€‘
- æˆ‘ä»¬çœ‹å·¦å­æ ‘å³å­æ ‘æœ‰æ²¡æœ‰ï¼Œæœ¬è´¨æ˜¯ååºéå†ã€‚æ³¨æ„è¿”å›å€¼æ˜¯Noneæˆ–è€…ç¬¬ä¸€ä¸ªå‡ºç°çš„q/p
```python
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if not root or root == q or root == p:
            return root
        left = self.lowestCommonAncestor(root.left, p, q)
        right = self.lowestCommonAncestor(root.right, p, q)
        if left and right:
            return root
        return left if left else right
```

ã€å˜å¼ Â·  äºŒå‰æœç´¢æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆã€‘[235_md](äºŒå‰æœç´¢æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/)
- æˆ‘çš„æ€è·¯ï¼šå¯ä»¥å€ŸåŠ©äºŒå‰æ ‘çš„æ€§è´¨æ‰¾ï¼å¦‚æœèŠ‚ç‚¹ä¸å­˜åœ¨ï¼ˆéå†åˆ°äº†Noneï¼‰ï¼Œåˆ™è¿”å›Noneï¼Œå¦‚æœéƒ½å°äºrootå°±åœ¨å·¦è¾¹æ‰¾ï¼Œéƒ½å¤§äºrootå°±åœ¨å³è¾¹æ‰¾ï¼Œå¦åˆ™å°±æ˜¯rootã€‚
```python
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if not root:
            return None
        if q.val < root.val and p.val < root.val:
            return self.lowestCommonAncestor(root.left, p, q)
        if q.val > root.val and p.val > root.val:
            return self.lowestCommonAncestor(root.right, p, q)
        else:
            return root
```

## äºŒå‰æœç´¢æ ‘ä¸­çš„æ’å…¥æ“ä½œ
[701_md](https://leetcode.cn/problems/insert-into-a-binary-search-tree/)
ã€æˆ‘çš„æ€è·¯ Â· æœç´¢æ ‘æ€§è´¨ + è¿­ä»£ã€‘
- æ³¨æ„ï¼šæœ€å¼€å§‹æ²¡æƒ³åˆ°çš„æƒ…å†µï¼šå¦‚æœæ˜¯ä¸ªç©ºæ ‘ï¼Œåº”è¯¥create TreeNode(val) as the root. 
```python
class Solution:
    def insertIntoBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
        if not root:
            return TreeNode(val)
        if not root.left and val < root.val:
            root.left = TreeNode(val)
            return root
        if not root.right and val > root.val:
            root.right = TreeNode(val)
            return root
        if val < root.val:
            self.insertIntoBST(root.left, val)
        if val > root.val:
            self.insertIntoBST(root.right, val)
        return root
```
ã€éšæƒ³å½• Â· ä¼˜åŒ–ã€‘
- å¯ä»¥é¿å…ä¸å¿…è¦çš„åˆ¤æ–­ï¼Œè¿˜å¯ä»¥åˆå¹¶å¾ˆå¤šæƒ…å†µ
- ï¼ˆä»€ä¹ˆæ—¶å€™æ‰å¯ä»¥å¾ˆè‡ªç„¶åœ°æƒ³åˆ°è¿™æ ·çš„å†™æ³•å‘€ï¼ï¼‰
```python
class Solution:
    def insertIntoBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
        if not root:
            return TreeNode(val)
        if root.val > val:
            root.left = self.insertIntoBST(root.left, val)
        if root.val < val:
            root.right = self.insertIntoBST(root.right, val)
        return root
```

## åˆ é™¤äºŒå‰æœç´¢æ ‘ä¸­çš„èŠ‚ç‚¹
[450_ez](https://leetcode.cn/problems/delete-node-in-a-bst/description/)
- è¿™é“é¢˜ç›´æ¥çœ‹çš„ç­”æ¡ˆï¼Œä»¥ä¸‹æ˜¯æ€»ç»“
- åˆ é™¤èŠ‚ç‚¹çš„é€»è¾‘ï¼š
	- åœæ­¢æƒ…å†µï¼šæ˜¯leafï¼Œåˆ™åˆ é™¤æ”¹å€¼/æ²¡åˆ°æ‰¾ï¼Œè¿”å›None
		- åªæœ‰å·¦å­æ ‘/å³å­æ ‘ï¼Œåˆ™ç›´æ¥æŠŠleafæ¢æˆè¯¥å­æ ‘çš„root
		- å¦‚æœæœ‰å·¦å³å­æ ‘ï¼Œåˆ™æ‰¾åˆ°å·¦å­æ ‘çš„æœ€å¤§å€¼ï¼ŒæŠŠè¯¥èŠ‚ç‚¹çš„valæ¢æˆè¿™ä¸ªæœ€å¤§å€¼ï¼Œç„¶ådeleteè¿™ä¸ªæ‹¥æœ‰æœ€å¤§å€¼çš„èŠ‚ç‚¹ï¼ˆä½¿ç”¨é€’å½’ï¼‰
	- å¦åˆ™ï¼Œç»§ç»­å¾€å·¦/å³è¾¹æ‰¾
	- è¿”å›å€¼ï¼šroot
	- éœ€è¦ä¸€ä¸ªhelper_functionï¼šå¾—åˆ°å·¦å­æ ‘çš„æœ€å¤§å€¼

```python
class Solution:
    def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:
        if not root:
            return None
        if root.val == key:
            if not root.left and not root.right:
                return None
            elif not root.left:
                return root.right
            elif not root.right:
                return root.left
            else:
                max_left_tree = self.get_max_val(root.left)
                root.val = max_left_tree
                root.left = self.deleteNode(root.left, max_left_tree)
                return root
        if root.val < key:
            root.right = self.deleteNode(root.right, key)
        if root.val > key:
            root.left = self.deleteNode(root.left, key)
        return root

    def get_max_val(self, root):
        while root.right:
            root = root.right
        return root.val
```
- æ³¨æ„ï¼špythonæ²¡æœ‰del nodeçš„æ“ä½œï¼Œhelper functionè¿™æ ·å†™ä¹Ÿå¹¶ä¸ä¼šæ”¹å˜åŸå§‹çš„rootå€¼ã€‚ç›¸å…³çŸ¥è¯†åœ¨ [_py_basics](_py/_py_basics.md) ä¸­é‡Œé¢åŒ…å«ä¸€äº›å‚¨å­˜åŸç†etcï¼ˆå¦‚é¢è¯•çš„å…«è‚¡ï¼‰
## ä¿®å‰ªäºŒå‰æœç´¢æ ‘
[669_md](https://leetcode.cn/problems/trim-a-binary-search-tree/description/)
è·³è¿‡

## å°†æœ‰åºæ•°ç»„è½¬æ¢ä¸ºäºŒå‰æœç´¢æ ‘
[108_ez](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)
ã€æˆ‘çš„æ€è·¯1 Â· è¿­ä»£ã€‘
ä¸ºäº†æ„å»ºAVLï¼Œè¦å°½é‡ä¿è¯å¹³åˆ†ï¼ˆè¿­ä»£çš„æ€æƒ³çœ‹ä¼¼æ—¥è¶‹ç†Ÿç»ƒäº†ï¼‰
```python
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:
        if not nums:
            return None
        if len(nums) == 1:
            return TreeNode(nums[0])
        mid = int(len(nums)/2)
        root = TreeNode(nums[mid])
        root.left = self.sortedArrayToBST(nums[0:mid])
        root.right = self.sortedArrayToBST(nums[mid+1:])
        return root
```

## æŠŠäºŒå‰æœç´¢æ ‘è½¬æ¢ä¸ºç´¯åŠ æ ‘
[538_md](https://leetcode.cn/problems/convert-bst-to-greater-tree/)
- ç¬¬ä¸€ä¸ªé”™è¯¯æ€è·¯ï¼šé‡‡ç”¨è¿­ä»£ã€‚åªåŠ è‡ªå·±å’Œå³è¾¹ã€‚è¿™æ ·å¯¼è‡´ç»“æœé”™è¯¯ï¼šå³å­æ ‘çš„å·¦å­æ ‘çš„å€¼å°±è¢«é—æ¼æ‰äº†ã€‚
ã€éšæƒ³å½• Â· åè¿‡æ¥çš„ä¸­åºéå†ã€‘
- å¦‚æœå€’ç€éå†å°±å¯ä»¥ä»å¤§åˆ°å°ä¾æ¬¡ç´¯åŠ ã€‚æŒ‰ç…§ä»å¤§åˆ°å°ï¼ˆå€’ç€çš„ä¸­åºéå†ï¼‰éå†ï¼Œåœ¨è®¾ç½®ä¸¤ä¸ªvariablesä¾¿å¯ä»¥å®ç°ã€‚
```python
class Solution:
    def convertBST(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        pre = None
        sum = 0
        def in_dfs(root):
            if not root:
                return
            nonlocal pre, sum
            in_dfs(root.right)
            sum += root.val
            root.val = sum
            in_dfs(root.left)
            return
        in_dfs(root)
        return root
```

# å¿ƒå¾—
äºŒå‰æ ‘ç›¸å…³çš„é¢˜ç›®ç›¸å¯¹å›ºå®šã€‚ä¸»è¦æ˜¯â€œé€’å½’â€œã€â€ï¼ˆå€ŸåŠ©queue/stackè¿­ä»£â€œè¿™ä¸¤å¤§æ€æƒ³ã€‚æŠ€å·§åœ¨äºå¦‚æœé‡åˆ°äºŒå‰æœç´¢æ ‘ï¼Œè¦å¤šå¤šæ€è€ƒå¦‚ä½•åˆ©ç”¨å…¶æ€§è´¨ï¼ˆæ¯”å¦‚ä¸­åºéå†æ€»æ˜¯æœ‰åºçš„ï¼‰ã€‚